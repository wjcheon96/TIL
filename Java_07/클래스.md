## 클래스

#### 객체 지향 프로그래밍(OOP)

소프트웨어를 개발할 때 부품에 해당하는 객체를 먼저 만들고, 하나씩 조립해서 완성된 프로그램을 만드는 기법.



##### 객체

물리적으로 존재하거나, 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 갖고, 다른 것과 식별이 가능한 것.

객체는 속성과 동작으로 구성되며, 자바는 이 속성과 동작들을 각각 필드와 메소드 라고 부른다.

현실 세계의 객체를 소프트웨어 객체로 설계하는 것을 객체 모델링(Object Modeling)이라고 하며, 객체 모델링은 현실 세계 객체의 속성과 동작을 추려내어 소프트웨어 객체의 필드와 메소드로 정의하는 과정으로 볼 수 있다.



##### 객체의 상호작용

현실 세계에서 일어나는 모든 현상은 객체와 객체 간의 상호작용으로 이루어지며, 소프트웨어에서 객체는 각각 독립적으로 존재하며, 다른 객체와 서로 상호작용을 하면서 동작한다. 객체들 사이의 상호작용 수단은 메소드로, 객체가 다른 객체의 기능을 이용하는 것이 메소드 호출이다.

메소드 호출은 객체에 도트(.) 연산자를 붙이고, 메소드 이름을 기술하면 된다. 도트 연산자는 객체의 필드와 메소드에 접근할때 사용된다.

```java
int leng = intArr.length;
```

매개값은 메소드를 실행하기 위해 필요한 데이터이고, 리턴값은 메소드가 실행하고 나서 호출한 곳으로 돌려주는 값이다.

```java
int result = Calculator.add(10, 20);	// 매개값 10과 20을 add 메소드로 더하고, 그 리턴값을 int 변수에 저장
```



##### 객체 간의 관계

객체는 개별적으로 사용될 수 있으나, 대부분 다른 객체와 관계를 맺고 있다. 이 관계의 종류는 집합, 사용, 상속 관계가 있으며, 집합 관계에 있는 객체는 하나의 부품이고, 각각의 하나는 완성품에 해당된다.

사용 관계는 객체 간의 상호작용으로, 객체는 다른 객체의 메소드를 호출하여 원하는 결과를 얻어낸다.

상속 관계는 상위(부모) 객체를 기반으로 하위(자식) 객체를 생성하는 관계로, 일반적으로 상위 객체는 종류를, 하위 객체는 구체적인 사물에 해당된다.

따라서 객체 지향 프로그래밍(OOP)는 완성품인 객체를 모델링하고, 집합 관계에 있는 부품 객체와 사용 관계에 있는 객체를 하나씩 설계한 후, 조립하는 방식으로 프로그램을 개발하는 기법이다.



##### 객체 지향 프로그래밍의 특징

객체 지향 프로그래밍의 특징은 캡슐화, 상속, 다형성을 들 수 있다.



##### 캡슐화

객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것을 말한다. 외부 객체는 객체 내부의 구조를 알지 못하며, 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.

필드와 메소드를 캡슐화해 보호하는 이유는 외부의 잘못된 사용으로 객체가 손상되지 않게 하는데 있다.

자바는 이와같이 캡슐화된 멤버를 노출시킬 것인지, 숨길 것인지를 결정하기 위해 접근 제한자(access Modifier)를 사용한다. 접근 제한자는 객체의 필드와 메소드의 사용범위를 제한함으로서 외부로부터 보호한다.



##### 상속

객체 지향 프로그래밍에서 상속은 부모 역할의 상위 객체와 하위 객체가 존재하며, 상위 객체는 자기가 가지고 있는 필드와 메소드를 하위 객체에게 물려주어, 하위 객체가 사용할 수 있게 해준다.

상속은 상위 객체를 재사용해 하위 객체를 쉽고 빨리 설계할 수 있게 도와주며, 잘 개발된 객체를 재사용해 새로운 객체로 만들이게 반복된 코드의 중복을 줄여준다.

상속은 상위 개체의 수정으로 모든 하위 객체들의 수정 효과를 가져오므로, 유지 보수시간을 최소화시켜주기도 한다.



##### 다형성

같은 타입이지만, 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 코드적 측면에서다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있게 해 주는데, 이 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다. 부모 타입에는 모든 자식 객체가 대입될 수 있고, 인터페이스 타입에는 모든 구현 객체가 대입될 수 있다.

다형성의 효과로 객체는 부품화가 가능하다.



#### 객체와 클래스

메모리에서 사용하고 싶은 캑체가 있으면, 클래스로 해당 객체를 만드는 작업을 하는데, 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있고, 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)라고 한다. 클래스로부터 객체를 만드는 과정을 인스턴스화 라고 하며, 하나의 클래스로부터 여러개의 인스턴스를 만들 수 있다.

객체 지향 프로그래밍 개발은 세가지 단계가 있는데, 클래스 설계-> 설계된 클래스를 갖고 사용할 객체 생성 -> 생성된 객체 이용 의 세 단계이다.



#### 클래스 선언

사용하고자 하는 객체를 구상하고, 그 객체의 대표 이름을 하나 결정해 이를 클래스 이름으로 한다. 클래스 이름은 다른 클래스와 식별할 목적으로 사용되므로, 자바의 식별자 작성 규칙에 따라 만들어야 한다.

| 번호 | 작성 규칙                                | 예                           |
| ---- | ---------------------------------------- | ---------------------------- |
| 1    | 하나 이상의 문자로 이루어져야 한다.      | Car. SportsCar               |
| 2    | 첫 번째 글자는 숫자가 올 수 없다         | Car, 3Car(X)                 |
| 3    | '$', '_'외의 특수 문자는 사용할 수 없다. | #Car, _Car, @Car(X), #Car(X) |
| 4    | 자바 키워드는 사용할 수 없다.            | int(X), for(X)               |

이와 같은 방법으로 클래스를 선언하며, 일반적으로 하나의 소스 파일에 하나의 클래스를 선언하나, 두 개 이상의 선언 또한 가능하다.

```java
public class Car{

}
```

주의할 점은 파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙일 수 있으며, 파일 이름과 일치하지 않는 클래스 선언에 public 접근 제한차를 붙이면 컴파일 에러가 발생한다.



#### 객체 생성과 클래스 변수

클래스로부터 객체를 생성하는 방법은 new 연산자를 사용한다. new 연산자 뒤에는 생성자가 오는데, 이 경우 생성자가 클래스() 형태를 갖는 것이다. new 연산자로 생성된 객체는 메모리 힙(heap)영역에 생성 되며, 메모리 내에서 생성된 객체의 위치를 모르면 객체를 사용할 수 없다. 따라서 new 연산자는 힙 영역에 객체를 생성시키고, 객체의 주소를 리턴하도록 되어 있다. 이 주소를 참조 타입인 클래스 변수에 저장 시, 변수를 통해 객체를 사용할 수 있다.

다음 예제는 클래스를 선언하고, 객체를 생성하는 과정이다.

```java
public class Student{
}
```

```java
public class StudentExample{
	public static void main(String[] args){
        Student s1 = new Student();
        System.out.println("s1 변수가 Student 객체를 참조합니다.");
        
        Student s2 = new Student();
        System.out.println("s2 변수가 또다른 Student 객체를 참조합니다.");
    }
}
```

메모리에 클래스 변수와 객체가 생성되고, 하나의 Student 클래스를 new 연산자를 사용한 만큼 객체를 메로리에 생성 후, 이 객체를 Student 클래스의 인스턴스 로서 자신만의 고유 데이터를 갖고 메모리에서 활동하게 한다. s1과 s2가 참조하는 Student 객체는 완전히 독립된 서로 다른 객체이다.

클래스는 두가지 용도를 지니는데, 하나는 라이브러리(API: Application Program Interface)용이고, 다른 하나는 실행용이다. 라이브러리 클래스는 다른 클래스에서 이용할 목적으로 설계되며, 실행 클래스는 프로그램의 실행 진입점인 main() 메소드를 제공하는 역할을 한다.

대부분의 객체 지향 프로그램은 라이브러리와 실행 클래스가 분리되어 있다.



#### 클래스의 구성 멤버

클래스에는 객체가 가져야 할 구성 멤버가 선언되는데, 구성 멤버에는 필드(Field), 생성자(Constructor), 메소드(Method)가 있따. 이 구성 멤버들은 생략 또는 복수 개가 작성 될 수 있다.

```java
public class ClassName{
    //필드
    int fileName;
    
    //생성자
    ClassName(){ ... }
    
    //메소드
    void methodName() { ... }
}
```



#### 필드

필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳으로, 선언 형태는 변수와 비슷하나, 필드를 변수라 부르지는 않는다. 변수는 생성자와 메소드 내에서만 사용되고, 생성자와 메소드가 실행 종료되면 자동 소멸되나, 필드는 생성자와 메소드 전체에서 사용되며, 객체가 소멸되지 않는 한 객체와 함께 존재한다.



##### 필드 선언

필드 선언은 클래스 중괄호 {} 블록 어디서든 가능하며, 생성자 선언과 메소드 선언의 앞 뒤 어느 곳에서든 선언이 가능하다. 하지만, 생성자와 메소드 중괄호 블록 내에서는 선언이 불가하며, 생성자와 메소드 중괄호 블록 내부에 선언된 것은 모두 로컬 변수가 된다. 필드 선언은 변수의 선언 형태와 비슷하며, 일각에서는 클래스 멤버 변수라고도 하는데, 필드라는 용어 그대로 사용하는 것이 좋다.

타입은 필드에 저장할 데이터의 종류를 결정하는데, 기본 타입과 참조타입 모두 올 수 있다.

필드의 초기값은 필드 선언 시 주어질 수도, 생략될 수도 있다.

필드의 초기값이 지정되지 않은 경우, 자동으로 기본 초기값으로 설정되는데, 정수 타입 필드는 0, 실수 타입은 0.0, 그리고 boolean은 false로 초기화되며, 참조 타입은 객체를 참조하지 않은 것과 같은 null로 초기화된다.



##### 필드 사용

필드를 사용한다는 것은 필드값을 읽고 변경하는 작업을 말하며, 클래스 내부의 생성자나 메소드에서 사용시 단순히 필드 이름으로 읽고 변경하면 되나, 클래스 외부에서 사용시 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용해야 한다. 그 이유는 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않기 떄문이다.

변수는 자신이 선언된 생성자 혹은 메소드 블록 내부에서 사용가능한 반면, 필드는 모든 생성자와 메소드에서 사용이 가능하다. 이때 외부 클래스에서 다른 클래스의 필드값을 사용하려면, 객체를 우선 생성해야 한다.

```java
Car mycar = new Car();
```

mycar라는 변수가 Car객체를 참조하면, 도트(.) 연산자를 사용해 speed 필드에 접근할 수 있다. 

```java
public class Car{
	//필드
    String company = "현대자동차";
    String model = "그랜저";
    String color = "검정";
    int maxSpeed = 350;
    int speed;
}
```

```java
public class CarExample{
	public static void main(String[] args){
        // 객체 생성
        Car myCar = new Car();
        
        // 필드 값 읽기
        System.out.println("제작회사: " + myCar.company);
        System.out.println("모델명: " + myCar.model);
        System.out.println("색깔: " + myCar.color);
        System.out.println("최고속도: " + myCar.maxSpeed);
        System.out.println("현재속도: " + myCar.speed);
        
        // 필드 값 변경
        myCar.speed = 60;
        System.out.println("수정된 속도: " + myCar.speed);
    }
}
```



#### 생성자

new 연산자와 같이 사용되어, 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다. 객체 초기화란 필드를 초기화하거나, 메소드를 호출해 객체를 사용할 준비를 하는 것을 말한다. 생성자를 실행시키지 않고는 클래스로부터 객체를 만들수 없으며, new 연산자에 의해 생성자가 성공적으로 실행되면 힙(heap) 영역에 객체가 생성되고 객체의 주소가 리턴된다. 만약 생성자가 성공적으로 실행되지 않고 예외가 발생했다면 객체는 생성되지 않는다.



##### 기본 생성자

모든 클래스는 생성자가 반드시 존재하며, 하나 이상을 가질 수 있다. 우리가 클래스 내부에 생성자 선언을 생략했다면, 컴파일러는 중괄호 { } 블록 내용이 비어있는 기본 생성자(Default Constructor)를 바이트 코드에 자동 추가시킨다.

클래스가 public class로 선언될 시, 기본 생성자에서도 public이 붙지만, 클래스가 public 없이 class로만 선언되면, 기본 생성자에도 public이 붙지 않는다. 

```java
public class Car{

}
```

```java
public class Car{
	public Car(){ }	//자동 추가
}
```

생성자를 생략시 기본 생성자가 위와 같이 자동으로 생성된다.

클래스에 생성자를 선언하지 않아도 new 연산자 뒤에 기본 생성자를 호출해서 객체를 생성시킬 수 있다.

```java
Car myCar = new Car();
```

그러나, 클래스에 명시적으로 선언한 생성자가 한 개라도 있으면, 컴파일러는 기본 생성자를 추가 하지 않으며, 명시적으로 생성자를 선언하는 이유는 객체를 다양하게 초기화하기 위해서이다.



##### 생성자 선언

기본 생성자 대신 생성자를 명시적으로 선언하는 방법은 다음과 같다.

```java
class( /*매개 변수 선언*/  ){
	//객체의 초기화 코드
}
```

생성자는 메소드와 비슷한 모양을 가지고 있으나, 리턴 타입이 없고, 클래스 이름이 동일하다. 생성자 블록 내부에는 객체 초기화 코드가 작성되는데, 일반적으로 필드에 초기값을 저장하거나, 메소드를 호출해 객체 사용 전에 필요한 준비를 한다. 매개 변수 선언은 생략할수도, 여러개를 선언해도 좋다. 매개 변수는 new 연산자로 생성자를 호출할 때 외부의 값을 생성자 블록 내부로 전달하는 역할을 한다.

```java
public class Car{
	//생성자
	Car(string model, String color, int maxSpeed){ ... }
}
```

클래스에 생성자가 명시적으로 선언된 경우, 반드시 선언된 생성자를 호출해 객체를 생성해야만 한다.



##### 필드 초기화

클래스로부터 객체가 생성될 때, 필드는 기본 초기값으로 자동 설정된다. 만약 다른 값으로 초기화를 하고 싶으면, 필드를 선언할 때 초기값을 주는 방법과, 생성자에서 초기값을 주는 방법이 있다. 필드를 선언할때 초기값을 주면 동일 클래스로부터 생성되는 객체들은 모두 같은 데이터를 갖게 되며, 객체 생성 후 변경 가능하나 생성 시점에 필드의 값이 모두 같다는 점이 있다.

```java
public class Korean{
    String nation = "대한민국";
    String name;
    String ssn;
}
```

```java
korean k1 = new Korean();
korean k2 = new Korean();
```

하지만, 객체 생성 시점에 외부에서 제공되는 다양한 값들로 초기화되어야 한다면 생성자에서 초기화를 해야 한다.

```java
public class Korean{
    //필드
    String nation = "대한민국";
    String name;
    String ssn;
    
    //생성자
    public korean(String n, String s){
        name = n;
        ssn = s;
    }
}
```

```java
korean k1 = new Korean("박자바", "011225-1234567");
korean k2 = new Korean("김자바", "930525-0654321")
```

관례적으로 필드와 동일한 이름을 갖는 매개 변수를 사용하며, 해결 방법은 필드 앞에 "this."을 붙인다. this는 객체 자신의 참조이다.

```java
public Korean(String name, String ssn){
	this.name = name;
	this.ssn = ssn;
}
```

객체의 필드는 하나가 아니라 여러 개가 있고, 이 필드를 모두 생성자에서 초기화하면 생성자의 매개 변수의 수는 객체의 필드 수만큼 선언되어야 한다. 그러나 실제로는 중요한 몇 개 필드만 매개 변수로 초기화하고, 나머지 필드들은 필드 선언 시 혹은 생성자 내부에서 임의의 값 또는 계산된 값으로 초기화한다. 아니면 객체 생성 후에 필드값을 별도로 저장한다.



##### 생성자 오버로딩

외부에서 제공되는 다양한 데이터들을 이용해서 객체를 초기화하려면, 생성자도 다양화될 필요가 있다. 다양한 방법으로 객체를 생성할 수 있도록 생성자 오버로딩이라는 것이 있는데, 이는 매개 변수를 달리하는 생성자를 여러개 선언하는 것을 말한다.

```java
public class Car{
    Car(){ ... }
    Car(String model){ ... }
    Car(String model, String color){ ... }
    Car(String model, String color, int maxSpeed) { ... }
}
```

생성자 오버로딩 시 주의할 점은 매개 변수의 타입과 개수 그리고 선언된 순서가 같을 경우 매개변수 이름만 바꾸는 것은 생성자 오버로딩이라 할 수 없다.

생성자가 오버로딩되어 있을 경우, new 연산자로 생성자를 호출할 때 제공되는 매개값의 타입과 수에 의해 호출될 생성자가 결정된다.

```
Car car1 = new Car();
Car car2 = new Car("그랜저");
Car car3 = new Car("그랜저", "흰색");
Car car4 = new Car("그랜저", "흰색", 300);
```



##### 다른 생성자 호출(this())

생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할 수 있는데, 매개변수의 수만 달리하고 필드 초기화 내용이 비슷한 생성자에서 이런 현상을 볼 수 있다. 필드 초기화 내용은 한 생성자에 집중적으로 작성하고, 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출하는 방법으로 개선 가능하다. 생성자에서 다른 생성자를 호출 시에는 this() 를 사용한다.

this()는 자신의 다른 생성자를 호출하는 코드로, 반드시 생성자의 첫줄에서만 허용되며, this() 의 매개값은 호출되는 생성자의 매개 변수 타입에 맞게 제공해야 한다. this() 다음에는 추가적인 실행문이 올 수 있으며, 호출되는 생성자의 실행이 끝나면 원래 생성자로 돌아와서 다음 실행문을 진행한다는 뜻이다.



#### 메소드

객체의 동작에 해당하는 중괄호 { } 블록을 말한다. 중괄호 블록은 이름을 갖고있는데, 이것이 메소드 이름이다. 메소드를 호출하게 되면, 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다. 메소드는 필드를 읽고 수정하는 역할도 하지만, 다른 객체를 생성해서 다양한 기능을 수행하기도 한다. 메소드는 객체 간의 데이터 전달 수단으로 사용되고, 외부로부터 매개값을 받을수도, 실행 후 어떤 값을 리턴할 수있다.



##### 메소드 선언

선언부(리턴타입, 메소드이름, 매개변수선언)와 실행 블록으로 구성된다. 메소드 선언부를 메소드 시그니처 라고도 한다.



##### 리턴 타입

리턴 타입은 메소드가 실행 후 리턴하는 값의 타입을 말한다. 메소드는 리턴값이 있을 수도 있고, 없을수도 있다. 메소드가 실행 후 결과를 호출한 곳에 넘겨줄 경우에는 리턴값이 있어야 한다. 리턴 값이 있느냐 없느냐에 따라 메소드를 호출하는 방법이 조금 다른데, 리턴값이 없으면 변수에 저장할 내용이 없으므로, 단순히 메소드만 호출하면 된다. 리턴값을 받기 위해 변수는 메소드의 리턴 타입인 double 타입으로 선언되어야 한다.

