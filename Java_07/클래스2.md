## 클래스2

#### 인스턴스 멤버와 this

인스턴스(instance) 멤버란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말하며, 이를 각각 인스턴스 필드, 인스턴스 메소드라고 부른다. 인스턴스 필드와 메소드는 객체에 소속된 멤버이르모 객체 없이는 사용할 수 없다.

객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하는 것과 마찬가지로 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있다. 객체는 자신을 "this"라고 하는데, 예를 들어 this.model은 자신이 갖고 있는 model 필드라는 뜻이다. this는 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용된다.

```java
Car(String model){
    this.model = model;
}
void setModel(String model){
    this.model = model;
}
```



#### 정적 멤버와 static

정적 멤버는 클래스에 고정된 멤버로 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다. 이들을 각각 정적 필드, 정적 메소드라고 부른다. 정적 멤버는 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 소속된 멤버이기 때문에 클래스 멤버라고 한ㄷ.



##### 정적 멤버 선언

정적 필드와 정적 메소드를 선언하는 방법은 필드와 메소드 선언시 static 키워드를 추가적으로 붙이면 된다.

```java
public class classSample{
    //정적 필드
    static fieldSample;
    
    //정적 메소드
    static methodSample(){ ... }
}
```

정적 필드와 정적 메소드는 클래스에 고정된 멤버이므로, 클래스 로더가 클래스(바이트 코드)를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리된다. 따라서 클래스 로딩이 끝나면 바로 사용이 가능하다.

필드를 선언할 때 인스턴스 필드로 선언할 것인지, 정적 필드로 선언할 것인지의 판단 기준은 객체마다 가지고 있어야할 데이터라면 인스턴스 필드로 선언하고, 객체마다 가지고 있을 필요성이 없는 공용적 데이터라면 정적 필드로 선언하는 것이 좋다.

메소드의 경우, 인스턴스 메소드로 선언할 것인가, 아니면 정적 메소드로 선언할 것인가의 판단 기준은 인스턴스 필드를 이용해서 실행해야 한다면 인스턴스 메소드로 선언하고, 인스턴스 필드를 이용하지 않는다면 정적 메소드로 선언한다.



##### 정적 멤버 사용

클래스가 메모리로 로딩되면 정적 멤버를 바로 사용할 수 있는데, 클래스 이름과 함께 도트(.) 연산자로 접근한다.

```java
public class Calculator{
    static double pi = 3.14159;
    static int plus(int x, int y){ return x+y; }
    static int minus(int x, int y){ return x-y; }
}
```

```
double result1 = 10*10*Calculator.pi;
int result2 = Calculator.plus(10,5);
int result3 = Calculator.minus(10,5);
```

정적 필드와 정적 메소드는 원칙적으로는 클래스 이름으로 접근해야 하나, 객체 참조 변수로도 접근이 가능하다.

```java
Calculator my Calc = new Calculator();
double result1 = 10*10*myCalc.pi;
int result2 = myCalc.plus(10,5);
int result3 = mtCalc.minus(10,5);
```

그러나 정적 요소는 클래스 이름으로 접근하는 것이 좋다.



##### 정적 초기화 블록

정적 필드는 필드 선언과 동시에 초기값을 주는 것이 보통인데, 계산이 필요한 초기화 작업이 있을 수 있다. 인스턴스 필드는 생성자에서 초기화하나, 정적 필드는 객체 생성 없이도 사용해야 하므로 생성자에서 초기화 작업을 할 수 없는데, 정적 필드를 위한 초기화는 정적 블록(static block)을 제공하며, 이 곳에서 정적 필드의 초기화 작업을 한다.

```java
static{
...
}
```

정적 블록은 클래스가 메모리로 로딩될 때 자동적으로 실행된다. 정적 블록은 클래스 내부에 여러개가 선언되어도 상관없으며, 클래스가 메모리로 로딩될 때 선언된 순서대로 실행된다. 



##### 정적 메소드와 블록 선언 시 주의할 점

정적 메소드와 정적 블록을 선언할 때의 주의점은 객체가 없어도 실행된다는 특징 때문에 이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다는 점이며, 또한 객체 자신의 참조인 this 키워드도 사용이 불가능하다.

정적 메소드와 정적 블록에서 인스턴스 멤버를 사용하고 싶다면, 객체를 먼저 생성하고 참조변수로 접근해야한다.

```java
public class ClassName{
    //인스턴스 필드와 메소드
    int field1;
    void method1(){ ... }
    
    //정적 필드와 메소드
    static int field2;
    static void method2(){ ... }
    
    //정적 블록
    static{
        field1 = 10;		// 객체가 없어도 실행되기에 컴파일 에러가 난다.
        method1();			// 위와 동일.
        field2 = 10;
        method2();
    }
}
```

정적 메소드와 정적 블록에서 인스턴스 멤버를 사용하고 싶다면 다음과 같이 객체를 먼저 생성하고 참조 변수로 접근해야 한다.

```java
static void Method3(){
	ClassName obj = new ClassName();
    obj.field1 = 10;
    obj.method1();
}
```

main() 메소드 또한 동일한 규칙이 적용되는데, main() 메소드 또한 정적 메소드이므로 객체 생성 없이 인스턴스 필드와 인스턴스 메소드를 main()메소드에서 바로 사용할 수 없다.



##### 싱글톤(Singleton)

전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있는데, 이를 하나만 생성된다 해서 싱글톤이라고 한다. 싱글톤을 만드려면 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야하는데, 이는 생성자를 호출한 만큼 객체가 생성되기 때문이다. 생성자를 외부에서 호출할 수 없도록 하려면 생성자 앞에 private 접근 제한자를 붙여주면 된다. 이후, 자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성해 초기화하며, 클래스 내부에서는 new 연산자로 생성자 호출이 가능하다. 정적 필드도 private 접근 제한자를 붙여 외부에서 필드값을 변경하지 못하도록 막고, 대신 외부에서 호출할 수 있는 정적 메소드인 getInstance()를 선언하고 정적 필드에서 참조하고 있는 자신의 객체를 리턴해준다.

```java
public class ClassName{
    //정적 필드
    private static ClassName singleton = new ClassName();
    
    //생성자
    private ClassName(){}
    
    //정적 메소드
    static ClassName getInstance(){
        return singleton;
    }
}
```

외부에서 객체를 얻는 유일한 방법은 getInstance() 메소드를 호출하는 방법으로, getInstance() 메소드는 단 하나의 객체만 리턴한다.



#### final 필드와 상수

##### final 필드

final 필드는 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중 수정할 수 없다는 뜻이다.

final 필드의 초기값을 줄 수 있는 방법은 두 가지로, 첫 번째는 필드 선언 시에 주는 방법이고, 두 번째는 생성자에서 주는 방법이다. 단순 값이라면 필드 선언 시에 주는 것이 제일 간단하다. 복잡한 초기화 코드가 필요하거나 객체 생성 시에 외부 데이터로 초기화해야 한다면 생성자에서 초기값을 지정해야 한다. 생성자는 final 필드의 최종 초기화를 마쳐야 하는데, 만약 초기화되지 않은 final 필드를 그대로 남겨두면 컴타일 에러가 발생한다.



##### 상수(static final)

일반적으로 불변의 값을 상수라고 부르며, 이런 불변의 값을 저장하는 필드를 자바에서는 상수(constant)라 한다. 불변의 값은 객체 마다 저장할 필요가 없는 공용성을 띄며, 여러 가지 값으로 초기화될 수 없기 때문에 객체마다 저장되고 생성자의 매개값을 통해 여러 가지 값을 가질 수 있는 final 필드와 다르다. 상수는 static이면서 final 이여야 하므로, static final 필드는 객체마다 저장되지 않고, 클래스에만 포함되며, 초기값이 저장되면 변경할 수 없다.

초기값이 단순 값이라면 선언 시에 주는 것이 일반적이나, 복잡한 초기화일 경우 정적 블록에서도 할 수 있다.

```java
static final 타입 상수;
static{
    상수 = 초기값;
}
```



#### 패키지

자바에서는 클래스를 체계적으로 관리하기 위해 패키지를 사용하는데, 폴더를 만들어 파일을 저장 관리 하듯, 패키지를 만들어 클래스를 저장 관리한다. 패키지의 물리적인 형태는 파일 시스템의 폴더이다.

패키지는 단순히 파일 시스템의 폴더 기능만 하는 것이 아니라 클래스의 일부분이며, 패키지는 클래스를 유일하게 만들어주는 식별자 역할을 한다. 클래스 이름이 동일하더라도, 패키지가 다르면 다른 클래스명으로 인식하며, 클래스의 전체 이름은 "패키지명 +클래스명"으로, 패키지가 상,하위로 구분되어 있다면 도트(.)를 사용해서 표현한다.

클래스를 이동할 경우에는 패키지 전체를 이동시켜야한다.



##### 패키지 선언

패키지는 클래스를 컴파일 하는 과정에서 자동적으로 생성되는 폴더이며, 컴파일러는 클래스에 포함 되어 있는 패키지 선언을 포고, 파일 시스템의 폴더로 자동 생성시킨다.

```java
package 상위패키지.하위패키지;

public class ClassName{ ... }
```

패키지 이름은 개발자가 임의대로 지어주면 되지만, 지켜야 할 몇가지 규칙이 있다.

* 숫자로 시작해서 안되며, _, $를 제외한 특수 문자를 사용하면 안된다.
* java로 시작하는 패키지는 자바 표준 API에서만 사용하므로 사용하면 안된다.
* 모두 소문자로 작성하는 것이 관례이다.



##### 패키지 선언이 포함된 클래스 컴파일

패키지 선언이 포함된 클래스를 명령 프롬프트에서 컴파일 할 경우, 단순히  javac.ClassName.java로 컴파일해서는 패키지 폴더가 생성되지 않으며, 패키지 폴더가 자동으로 생성되려면 javac 명령어 다음에 -d 옵션을 추가하고 패키지가 생성될 경로를 다음과 같이 지정해야 한다.

```
javac -d . ClassName.java
javac -d ..\bin ClassName.java
javac -d C:\Temp\bin ClassName.java
```



##### import 문

같은 패키지에 속하는 클래스들은 아무런 조건 없이 다른 클래스를 사용할 수 있으나, 다른 패키지에 속하는 클래스를 사용하려면 두가지 방법 중 하나를 사용해야 한다. 첫 번째 방법은 패키지와 클래스를 모두 기술하는 것이다.

```java
package com.mycompany;

public class Car{
    com.hankook.Tire tire = new com.hankook.Tire();
}
```

패키지 이름이 짧은 경우는 불편함 없이 쓸 수 있으나, 패키지 이름이 길거나 사용할 클래스 수가 많다면 주로 import 문을 사용하는데, 사용하고자 하는 패키지를 import 문으로 선언해, 클래스를 사용할 때 패키지를 생략하는 것이다.

```java
package com.mycompany;

import com.hankook.Tire;

public class Car {
    Tire tire = new Tire();
}
```

import문이 작성되는 위치는 패키지 선언과 클래스 선언의 사이이며, 패키지에 포함된 다수의 클래스를 사용해야 할 시 클래스 별로 import 문을 작성할 필요 없이 클래스 이름을 생략하고 *를 사용해 import 문을 작성해, 하위 클래스를 전부 import 시킬 수 있다. import 문의 개수는 제한이 없으며, 필요한 패키지가 있다면 추가하는데 문제가 없다. 주의할 점은 import 문으로 지정된 패키지의 하위 패키지는 import 대상이 아니다. 따라서 하위 패키지의 클래스를 사용하고 싶다면, 상위 패키지와 하위 패키지의 클래스 모두 import 시켜주어야한다.

서로 다른 패키지에 동일한 클래스 이름이 존재하고, 두 패키지가 모두 import 되어 있을 경우에는 패키지 이름 전체를 기술하는 방법을 사용해야만 한다.



#### 접근 제한자

main() 메소드를 가지지 않는 대부분의 클래스는 외부 클래스에서 이용할 목적으로 설계된 라이브러리 클래스이다. 라이브러리 클래스를 설계할 때 외부 클래스에서 접근할 수 있는 멤버와 접근할 수 없는 멤버로 구분해 필드, 생성자, 메소드를 설계하는 것이 바람직하며, 객체 생성을 막기 위해 생성자를 호출하지 못하게 하거나 객체의 특정 데이터를 보호하기 위해 해당 필드로 접근하지 못하게 막아야 한다. 그리고 특정 메소드를 호출할 수 없도록 제한할 필요가 있는데, 이를 자바에서는 접근 제한자(Access Modifire)를 제공한다.

접근 제한자는 public, protected default, private의 4가지 종류가 있으며, public은 공개한다는 의미를 갖고, 외부 클래스가 자유롭게 사용할 수 있는 공개 멤버를 만든다. protected 접근 제한자는 같은 패키지 또는 자식 클래스에서만 사용 가능한 멤버를 만든다. private 접근 제한자는 외부에 노출되지 않는 멤버를 만들고, 위 세 가지 접근 제한자가 적용되지 않은 멤버는 default 접근 제한을 갖는다. default 접근 제한자는 같은 패키지에 소속된 클래스에서만 사용할 수 있는 멤버를 만든다.

| 접근 제한 | 적용 대상                    | 접근할 수 없는 클래스                          |
| --------- | ---------------------------- | ---------------------------------------------- |
| public    | 클래스, 필드, 생성자, 메소드 | 없음                                           |
| protected | 필드, 생성자, 메소드         | 자식 클래스가 아닌 다른 패키지에 소속된 클래스 |
| default   | 클래스, 필드, 생성자, 메소드 | 다른 패키지에 소속된 클래스                    |
| private   | 필드 ,생성자, 메소드         | 모든 외부 클래스                               |



##### 클래스의 접근 제한

클래스를 선언할 때 고려해야 할 사항은 같은 패키지 내에서만 사용할 것인지, 아니면 다른 패키지에서도 사용할 수 있도록 할 것인지 결정해야 한다. 클래스에 적용 가능한 접근 제한은 public과 default 두가지이다.

```java
//default 접근 제한
class 클래스 { ... }

//public 접근 제한
public class 클래스 { ... }
```



###### default 접근 제한

클래스를 선언할 때 public을 생략하면, 클래스는 default 접근 제한을 가지며, 클래스가 default 접근 제한을 가지면 같은 패키지에서는 아무 제약 없이 사용 가능하나, 다른 패키지에서는 사용이 불가하다.



##### public 접근 제한

클래스를 선언할 때 public 접근 제한자를 붙이면 클래스는 public 접근 제한을 가진다. public 접근 제한을 가지면 모든 패키지에서 아무런 제한 없이 사용 가능하며 ,클래스를 다른 개발자가 사용할 수 있도록 라이브러리 클래스로 개발하려면 public 접근 제한을 갖게 해야한다.



##### 생성자의 접근 제한

객체를 생성하기 위해서는 new 연산자로 생성자를 호출해야 하는데, 생성자를 어디에서나 호출할 수 있는 것은 아니다. 생성자가 어떤 접근 제한을 갖느냐에 따라 호출 여부가 결정되며, public, protected, default, private 의 4가지 접근 제한을 모두 가질 수 있다.

```java
public class ClassName{
    //public 접근 제한
    public ClassName(...) { ... }
    
    //protected 접근 제한
    protected ClassName(...) { ... }
    
    //default 접근 제한
    ClassName(...) { ... }
    
    //private 접근 제한
    private ClassName( ... ) { ... } 
}
```

클래스에 생성자를 선언하지 않으면 컴파일러에 의해 자동적으로 기본 생성자가 추가되며, 자동으로 생성되는 기본 생성자의 접근 제한은 클래스의 접근 제한과 동일하다. 

| 접근 제한자 | 생성자      | 설명                                                         |
| ----------- | ----------- | ------------------------------------------------------------ |
| public      | 클래스(...) | 아무런 제한 없이 생성자 호출 가능. <br />생성자가 public 접근 제한이면 클래스도 public 접근 제한을 가진다.<br />클래스가 default 접근 제한을 가지면 클래스 사용이 같은 패키지로 한정되므로, <br />생성자가 public접근 제한을 가져도 같은 패키지에서만 사용 가능하다. |
| protected   | 클래스(...) | default와 마찬가지로 같은 패키지에 속하는 클래스에서 생성자 호출 가능.<br />다른 패키지에 속한 클래스가 해당 클래스의 자식 클래스라면 생성자를 호출 가능 |
| default     | 클래스(...) | public or private을 생략시 default 접근 제한을 가짐.<br />같은 패키지에서는 아무 제한없이 생성자를 호출가능하나, 다른 패키지에서는 호출 불가. |
| private     | 클래스(...) | 동일 패키지건 다른 패키지건 생성자를 호출 할 수 없다.<br />클래스 외부에서 new 연산자로 객체 생성 불가.<br />오로지 클래스 내부에서만 생성자 호출 및 객체 생성 가능. |

가끔 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있는데, 이럴 경우 여러개의 객체를 만들지 못하도록 설계하는 싱글톤 패턴을 사용하면 된다.



##### 필드와 메소드의 접근 제한

필드와 메소드를 선언할 때 고려해야 할 사항은 클래스 내부에서만 사용할 것인지, 패키지 내에서만 사용할 것인지, 아니면 다른 패키지에서도 사용할 수 있도록 할 것인지 결정해야 한다. 이는 필드와 메소드가 어떤 접근을 갖느냐에 따라 달라지며, 필드와 메소드는 public, protected, default, private 접근 제한을 가질 수 있다.

| 접근 제한자 | 생성자                | 설명                                                         |
| ----------- | --------------------- | ------------------------------------------------------------ |
| public      | 필드<br />메소드(...) | 아무런 제한 없이 생성자 호출 가능. <br />필드와 메소드가 public 접근 제한이면 클래스도 public 접근 제한을 가진다. |
| protected   | 필드<br />메소드(...) | default와 마찬가지로 같은 패키지에 속하는 클래스에서 필드와 메소드 호출 가능.<br />다른 패키지에 속한 클래스가 해당 클래스의 자식 클래스라면 필드와 메소드를 호출 가능 |
| default     | 필드<br />메소드(...) | public or private을 생략시 default 접근 제한을 가짐.<br />같은 패키지에서는 아무 제한없이 필드와 메소드를 호출가능하나, 다른 패키지에서는 호출 불가. |
| private     | 필드<br />메소드(...) | 동일 패키지건 다른 패키지건 필드와 메소드를 호출 할 수 없다.<br />클래스 외부에서 new 연산자로 객체 생성 불가.<br />오로지 클래스 내부에서만 필드와 메소드를 호출 및 객체 생성 가능. |



#### Getter 와 Setter 메소드

객체 지향 프로그래밍에서 객체의 데이터는 객체 외부에서 직접적으로 접근하는 것을 막는데, 그 이유는 객체의 데이터를 외부에서 마음대로 읽고 변경할 경우, 객체의 무결성(결점이 없는 성질)이 깨어질 수 있기 때문이다.

이러한 문제를 해결하기 위해 객체 지향 프로그래밍에서는 메소드를 통해 데이터를 변경하는 방법을 선호한다. 데이터는 외부에서 접근할 수 없도록 막고, 메소드는 공개해서 외부에서 메소드를 통해 데이터에 접근하도록 유도하며, 이렇게 하는 이유는 메소드는 매개값을 검증해서 유효한 값만 데이터로 저장하기 위함이다.

```java
void setSpeed(double speed){
    if(speed<0){
        this.speed = 0;
        return;
    }else{
        this.speed = speed;
    }
}
```

외부에서 객체의 데이터를 읽을 때도 메소드를 사용하는 것이 좋다. 객체 외부에서 객체의 필드값을 사용하기에 부적절한 경우도 있는데, 이런 경우에는 메소드로 필드값을 가공한 후 외부로 전달하면 된다. 이를 Getter 메소드라고 한다.

```java
double getSpeed(){
    double km = speed*1.6;
    return km;
}
```

클래스를 선언할 때 가능하다면 필드를 private으로 선언해 외부로부터 보호하고, 필드에 대한 Setter와 Getter 메소드를 작성해 필드값을 안전하게 변경/사용하는 것이 좋다.

```java
private 타입 fieldName;
//Getter
public 리턴타입 getFieldName(){
    return fieldName;
}

//Setter
public void setFieldName(타입 fieldName){
    this.fieldName = fieldName;
}
```

필드 타입이 boolean일 경우 Getter는 get이 아닌 is로 시작한다.

```java
private boolean stop;

//Getter
public boolean isStop(){		//리턴 타입 : 필드타입
    return stop;				//리턴값 : 필드값
}

//Setter
public void setStop(boolean stop){	//리턴 타입: void
    this.stop = stop;				//매개 변수 타입 : 필드 타입
}
```

만약 외부에서 필드값을 읽을 수만 읽고 변경하지 못하게 하려면(읽기 전용) Getter 메소드만 선언하거나, Setter 메소드를 private으로 선언하면 된다.



#### 어노테이션

어노테이션(Annotation)은 메타데이터(metadata)라고 볼 수 있다. 메타데이터란 에플리케이션이 처리해야 할 데이터가 아니라, 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지를 알려주는 정보이다. 어노테이션은 ``@AnnotationName``과 같이 작성한다.

어노테이션은 세가지 용도로 사용 된다.

* 컴파일러에게 코드 문법 에러를 체크하도록 정보 제공
* 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
* 실행 시(런타임 시) 특정 기능을 실행하도록 정보 제공

컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공하는 가장 대표적인 예는 @Override 어노테이션이 있다. @Override는 메소드 선언시 사용하며, 메소드가 오버라이드(재정의)된 것임을 컴파일러에게 알려주어, 컴파일러가 오버라이드 검사를 해준다. 정확히 오버라이드가 되지 않았으면 컴파일러는 에러를 발생시키며, 어노테이션은 빌드 시 자동으로 XML 설정 파일을 생성하거나, 베포를 위해 JAR 압축 파일을 생성하는데도 사용된다. 또한, 실행 시 클래스의 역할을 정의하기도 한다.



##### 어노테이션 타입 정의와 적용

어노테이션 타입을 적용하는 방법은 인터페이스를 정의하는 것과 유사하다. 다음과 같이 @interface를 사용해 어노테이션을 정의하며, 그 뒤에 사용할 어노테이션 이름이 온다.

```java
public @interface AnnotationName{
}
```

이렇게 정의한 어노테이션은 코드에서 다음과 같이 사용한다.

```java
@AnnotationName
```

어노테이션은 엘리먼트(element)를 멤버로 가질 수 있다. 각 엘리먼트는 타입과 이름으로 구성되며, 디폴트 값을 가질 수 있다.

```java
public @interface AnnotationName{
    타입 elementName() [default 값];
}
```

엘리먼트의 타입으로는 int나 double 같은 기본 데이터 타입, String, 열거 타입, Class 타입, 그리고 이들의 배열 타입을 사용할 수 있다. 엘리먼트의 이름 뒤에는 메소드를 작성하는 것과 같이 ()를 붙여야 한다.

```java
public @interface AnnotationName{
    String elementName();
    int elementName2() default 5;
}
```

이렇게 정의한 어노테이션을 코드에 적용시킬떄는 다음과 같다.

```java
@AnnotationName(elementName1 = "값", elementName2=3);
또는
@AnnotationName(elementName1="값");
```

디폴트 값이 없으면 반드시 값을 기술해야 하며, 디폴트 값이 있으면 생략 가능하다. 또한 어노테이션은 기본 엘리먼트인 value를 가질 수 있다.

```java
public @interface AnootationName{
	String value();
	int elementName() default 5;
}
```

Value 엘리먼트를 가진 어노테이션을 코드에서 적용시킬 때는 값만 기술할 수 있다. 이 값은 기본 엘리먼트인 value 값으로 자동 설정된다.

```java
@AnnotationName("값");
```

value 엘리먼트와 다른 엘리먼트의 값을 동시에 주고 싶으면 정상적인 방법으로 지정하면 된다.

```java
@AnnotationName(value="값", element=3);
```



##### 어노테이션 적용 대상

어노테이션을 적용할 수 있는 대상은 java.lang.annotation.ElementType 열거 상수로, 다음과 같이 정의되어있다.

| ElementType 열거 상수 | 적용 대상                     |
| --------------------- | ----------------------------- |
| TYPE                  | 클래스, 인터페이스, 열거 타입 |
| ANNOTATION_TYPE       | 어노테이션                    |
| FIELD                 | 필드                          |
| CONSTRUCTOR           | 생성자                        |
| METHOD                | 메소드                        |
| LOCAL_VARIABLE        | 로컬 변수                     |
| PACKAGE               | 패키지                        |

어노테이션이 적용될 대상을 지정할 때는 @Target 어노테이션을 사용한다. @Target의 기본 엘리먼트인 value는 ElementType 배열을 값으로 가진다. 이것은 어노테이션이 적용될 대상을 복수 개로 지정하기 위해서이다.

```java
@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
public @interface AnnotationName{
}
```

위와 같이 어노테이션이 정의된 경우, 클래스, 필드, 메소드는 어노테이션을 적용시킬 수 있고, 생성자는 적용시킬 수 없다.

```java
@AnnotationName
public clas ClassName{
	@AnnotationName
    private String fieldName;
    
    //@AnnotationName(x)	--- @Target에 CONSTRUCT가 없어 생성자 적용 불가
    public ClassName(){}
    
    @AnnotationName
    public void methodName(){}
}
```



##### 어노테이션 유지 정책

어노테이션 정의시 사용 용도에 따라 @AnnotationName을 어느 범위까지 유지할 것인지 지정해야 한다. 소스 상에 유지할 것인지, 컴파일된 클래스까지 유지할 것인지, 런타임 시에도 유지할 것인지를 지정해야 하며, 어노테이션 유지 정책은 java.lang.annotation.RententionPolicy 열거 상수로 다음과 같이 정의되어있다.

| RetentionPolicy 열거 상수 | 설명                                                         |
| ------------------------- | ------------------------------------------------------------ |
| SOURCE                    | 소스상에서만 어노테이션 정보를 유지.<br />소스 코드를 분석할 때만 의미가 있으며, 바이트 코드 파일에는 정보가 남지 않는다. |
| CLASS                     | 바이트 코드 파일까지 어노테이션 정보를 유지.<br />리플렉션을 이용해 어노테이션 정보를 얻을 수 없음. |
| RUNTIME                   | 바이트 코드 파일까지 어노테이션 정보를 유지하며, 리플렉션을 이용해 런타임시 어노테이션 정보를 얻음. |

리플렉션은 런타임 시 클래스의 메타 정보를 얻는 기능을 말하며, 리플렉션을 이용해 런타임 시 어노테이션 정보를 얻으려면 어노테이션 유지 정책을  RUNTIME으로 설정해야 한다. 어노테이션 유지 정책을 지정할 때는 @Retention 어노테이션을 사용하며, 기본 엘리먼트인 value 는 RetentionPolicy 타입이므로, 위 세 가지 상수 중 하나를 지정하면 된다. 

```java
@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Annotation{
}
```



##### 런타임 시 어노테이션 정보 사용하기

어노테이션 자체는 아무런 동작을 갖지 않는 단순한 표식이나, 리플렉션을 이용해 어노테이션의 적용 여부와 엘리먼트 값을 읽고 적절히 처리할 수 있다. 클래스에 적용된 어노테이션 정보를 얻으려면 java.lang.Class를 이용하면 되나, 필드, 생성자, 메소드에 적용된 어노테이션 정보를 얻으려면 Class의 다음 메소드를 통해 java.lang.reflect 패키지의 Field, Constructor, Method 타입의 배열을 얻어야 한다.

| 리턴 타입     | 메소드명(매개 변수)  | 설명                                  |
| ------------- | -------------------- | ------------------------------------- |
| Field[]       | getFields()          | 필드 정보를 Field 배열로 리턴         |
| Constructor[] | getConstructors()    | 생성자 정보를 Constructor 배열로 리턴 |
| Method[]      | getDeclaredMethods() | 메소드 정보를 Method 배열로 리턴      |

이후 Class, Field, Constructor, Method가 갖고 있는 다음 메소드를 호출해 적용된 어노테이션 정보를 얻을 수 있다.