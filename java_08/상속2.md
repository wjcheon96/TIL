## 상속2

#### 타입 변환과 다형성

다형성은 같은 타입이지만 실행 결과과 다양한 객체를 이용할 수 있는 성질을 말한다. 코드 측면에서 다형성은 하나의 타입에 여러 객체를 대입함으로서 다양한 기능을 이용할 수 있도록 해준다. 다형성을 위해 자바는 부모 클래스로 타입 변환을 허용한다. 즉, 부모 타입에 모든 자식 객체가 대입될 수 있고, 이를 이용해 객체의 부품화가 가능하다.



##### 자동 타입 변환

프로그램 도중에 자동적으로 타입 변환이 일어나는 것을 말하며, 조건은 다음과 같다.

```java
부모클래스 변수 = 자식클래스타입;
```

자동 타입 변환의 개념은 자식은 부모의 특징과 기능을 상속받기 때문에 부모와 동일하게 취급될 수 있다는 것이다. 즉, 부모 클래스의 경우 생성되는 메모리 상태에 따르면, 타입이 다를지언정, 동일 객체를 참조한다는 특성이 있다.

부모 타입으로 자동 타입 변환된 이후에는 부모 클래스에 선언된 필드와 메소드만 접근이 가능하다. 비록 변수는 자식 객체를 참조하나, 변수로 접근 가능한 멤버는 부모 클래스 멤버로만 한정된다. 그러나 예외가 있는데, 메소드가 자식 클래스에서 오버라이딩 되었다면 자식 클래스의 메소드가 대신 호출된다. 이는 다형성과 관련이 있기에 매우 중요한 성질이다.



##### 필드의 다형성

다형성이란 동일한 타입을 사용하지만 다양한 결과가 나오는 성질을 말하며, 주로 필드의 값을 다양화함으로써 실행 결과가 다르게 나오도록 구현한다. 이때 필드의 타입은 변함이 없지만, 실행 도중에 어떤 객체를 필드로 저장하느냐에 따라 실행 결과가 달라질 수 있다. 이것이 필드의 다형성이다.

프로그램은 수많은 객체들이 서로 연결되고 각자의 역할을 하는데, 이 객체들은 다른 객체들로 교체될 수 있어야 한다. 사용방법은 동일하나, 실행 결과는 더 우수하게 나올 수 있어야 하며, 이를 프로그램으로 구현하기 위해서 상속과 오버라이딩, 타입 변환을 이용한다. 부모 클래스를 상속하는 자식 클래스는 부모가 가지고 있는 필드와 메소드를 가지고 있으니 사용 방법이 동일하며, 부모의 메소드를 오버라이딩(재정의)해서 메소드의 실행 내용을 변경함으로서 더 우수한 실행 결과가 나오게 할 수 있다. 그리고 자식 타입을 부모 타입으로 변환시킬 수 있다.

```java
class Clar{
	//필드
    Tire frontLeftTire = new Tire();
    Tire frontRightTire = new Tire();
    Tire backLeftTire = new Tire();
    Tire backRightTire = new Tire();
    //메소드
    void run(){ ... }
}
```

```java
Car myCar = new Car();
myCar.frontRightTire = new HankookTire();
myCar.backLeftTire = new kumhoTire();
myCar.run();
```

자식 타입은 부모 타입으로 자동 타입 변환이 되므로 문제가 되지 않는다.

```java
void run(){
    frontLeftTire.roll();
    frontRightTire.roll();
    backLeftTire.roll();
    backRightTire.roll();
}
```



##### 하나의 배열로 객체 관리

동일한 타입의 값들은 배열로 관리하는게 유리하기에, 객체를 배열로 관리하는것이 깔끔하다.

```java
class Car {
    Tire frontLeftTire = new Tire("앞왼쪽", 6);
    Tire frontRightTire = new Tire("앞오른쪽", 2);
    Tire backLeftTire = new Tire("뒤왼쪽", 3);
    Tire backRightTire = new Tire("뒤오른쪽", 4);
}
```

```java
class Car {
    Tire [] tires = {
        new Tire("앞왼쪽", 6),
        new Tire("앞오른쪽", 2),
        new Tire("뒤왼쪽", 3),
        new Tire("뒤오른쪽", 4)
    };
}
```

```java
tires[1] = new KumhoTire("앞오른쪽",13); 
```

위와 같이 변경할 수 있다.



##### 매개 변수의 다형성

자동 타입 변환은 필드의 값을 대입할 때도 발생하나, 주로 메소드를 호출할 때 많이 발생한다. 메소드를 호출할 때에는 매개 변수의 타입과 동일한 매개값을 지정하는 것이 정석이지만, 매개값을 다양화 하기 위해 매개 변수에 자식 타입 객체를 지정할 수도 있다. 

```java
class Driver{
    void drive(Vehicle vehicle){
        vehicle.run();
    }
}
```

위 객체를 정상적으로 호출하면 다음과 같다.

```java
Driver driver = new Driver();
vehicle vehicle = new Vehicle();
driver.drive(vehicle);
```

이 객체의 자식 클래스를 해당 메소드의 매개값으로 넘겨주면 다음과 같다.

```java
Driver driver = new Driver();
Bus bus = new Bus();
driver.drive(bus);
```

매개변수를 선언한 경우라도, 상속받는 객체가 매개값으로 사용되면 자동 타입 변환이 발생한다.

```java
Vechicle vehicle = bus;		//자동 형 변환
```

즉, 매개 변수의 타입이 클래스일 경우, 해당 클래스의 객체뿐만 아니라 자식 객체까지도 매개값으로 사용할 수 있다. 매개값으로 어떤 자식 객체가 제공되느냐에 따라 메소드의 실행 결과는 다양해질 수 있다(매개변수의 다형성). 자식 객체가 부모의 메소드를 재정의(오버라이딩)했다면 메소드 내부에서 오버라이딩된 메소드를 호출함으로서 메소드의 실행 결과는 다양해진다.

```java
void drive(Vehicle vehicle){	//Vehicle은 자식 객체
    vehicle.run();	//자식 객체가 재정의한 run()메소드 실행
}
```



##### 강제 타입 변환(Casting)

부모 타입을 자식 타입으로 변환 시키는 것을 말하며, 모든 부모 타입을 자식 클래스 타입으로 강제 변환할 수 있는 건 아니다. 자식 타입이 부모 타입으로 자동 변환한 후, 다시 자식 타입으로 변환할 때 강제 타입 변환을 사용할 수 있다.

```java
자식클래스 변수 = (자식클래스) 부모클래스타입;
```

자식 타입이 부모 타입으로 자동 변환하면, 부모 타입에 선언된 필드와 메소드만 사용 가능하다는 제약사항이 따른다. 만약 자식 타입에 선언된 필드와 메소드를 꼭 사용해야 한다면 강제 타입 변환을 해서 다시 자식 타입으로 변환한 다음 자식 타입의 필드와 메소드를 사용하면 된다.



##### 객체 타입 확인(instanceof)

강제 타입 변환은 자식 타입이 부모 타입으로 변환되어 있는 상태에서만 가능하기 때문에 다음과 같이 부모 타입의 변수가 부모 객체를 참조할 경우 자식 타입으로 변환할 수 없다.

```java
Parent parent = new Parent();
Child child = (Child) parent;	//강제 타입변환 불가능
```

부모 변수가 참조하는 객체가 부모 객체인지 확인하는 방법, 즉 어떤 객체가 어떤 클래스의 인스턴스인지 확인하려면 instanceof 연산자를 사용할 수 있다. instanceof 연산자의 좌항은 객체가 오고, 우항은 타입이 오는데, 좌장의 객체가 우항의 인스턴스이면(우항의 타입으로 객체 생성) true를 산출하고 그렇지 않으면 false를 산출한다.

```java
boolean result = 좌항(객체) instanceof 우항(타입)
```

instanceof 연산자는 매개값의 타입을 조사할때 주로 사용된다. 메소드 내에서 강제 타입 변환이 필요한 경우 반드시 매개값이 어떤 객체인지 instanceof 연산자로 확인하고 안전하게 강제 타입 변환을 해야한다.

