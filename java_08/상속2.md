## 상속2

#### 타입 변환과 다형성

다형성은 같은 타입이지만 실행 결과과 다양한 객체를 이용할 수 있는 성질을 말한다. 코드 측면에서 다형성은 하나의 타입에 여러 객체를 대입함으로서 다양한 기능을 이용할 수 있도록 해준다. 다형성을 위해 자바는 부모 클래스로 타입 변환을 허용한다. 즉, 부모 타입에 모든 자식 객체가 대입될 수 있고, 이를 이용해 객체의 부품화가 가능하다.



##### 자동 타입 변환

프로그램 도중에 자동적으로 타입 변환이 일어나는 것을 말하며, 조건은 다음과 같다.

```java
부모클래스 변수 = 자식클래스타입;
```

자동 타입 변환의 개념은 자식은 부모의 특징과 기능을 상속받기 때문에 부모와 동일하게 취급될 수 있다는 것이다. 즉, 부모 클래스의 경우 생성되는 메모리 상태에 따르면, 타입이 다를지언정, 동일 객체를 참조한다는 특성이 있다.

부모 타입으로 자동 타입 변환된 이후에는 부모 클래스에 선언된 필드와 메소드만 접근이 가능하다. 비록 변수는 자식 객체를 참조하나, 변수로 접근 가능한 멤버는 부모 클래스 멤버로만 한정된다. 그러나 예외가 있는데, 메소드가 자식 클래스에서 오버라이딩 되었다면 자식 클래스의 메소드가 대신 호출된다. 이는 다형성과 관련이 있기에 매우 중요한 성질이다.



##### 필드의 다형성

다형성이란 동일한 타입을 사용하지만 다양한 결과가 나오는 성질을 말하며, 주로 필드의 값을 다양화함으로써 실행 결과가 다르게 나오도록 구현한다. 이때 필드의 타입은 변함이 없지만, 실행 도중에 어떤 객체를 필드로 저장하느냐에 따라 실행 결과가 달라질 수 있다. 이것이 필드의 다형성이다.

프로그램은 수많은 객체들이 서로 연결되고 각자의 역할을 하는데, 이 객체들은 다른 객체들로 교체될 수 있어야 한다. 사용방법은 동일하나, 실행 결과는 더 우수하게 나올 수 있어야 하며, 이를 프로그램으로 구현하기 위해서 상속과 오버라이딩, 타입 변환을 이용한다. 부모 클래스를 상속하는 자식 클래스는 부모가 가지고 있는 필드와 메소드를 가지고 있으니 사용 방법이 동일하며, 부모의 메소드를 오버라이딩(재정의)해서 메소드의 실행 내용을 변경함으로서 더 우수한 실행 결과가 나오게 할 수 있다. 그리고 자식 타입을 부모 타입으로 변환시킬 수 있다.

```java
class Clar{
	//필드
    Tire frontLeftTire = new Tire();
    Tire frontRightTire = new Tire();
    Tire backLeftTire = new Tire();
    Tire backRightTire = new Tire();
    //메소드
    void run(){ ... }
}
```

```java
Car myCar = new Car();
myCar.frontRightTire = new HankookTire();
myCar.backLeftTire = new kumhoTire();
myCar.run();
```

자식 타입은 부모 타입으로 자동 타입 변환이 되므로 문제가 되지 않는다.

```java
void run(){
    frontLeftTire.roll();
    frontRightTire.roll();
    backLeftTire.roll();
    backRightTire.roll();
}
```



##### 하나의 배열로 객체 관리

동일한 타입의 값들은 배열로 관리하는게 유리하기에, 객체를 배열로 관리하는것이 깔끔하다.

```java
class Car {
    Tire frontLeftTire = new Tire("앞왼쪽", 6);
    Tire frontRightTire = new Tire("앞오른쪽", 2);
    Tire backLeftTire = new Tire("뒤왼쪽", 3);
    Tire backRightTire = new Tire("뒤오른쪽", 4);
}
```

```java
class Car {
    Tire [] tires = {
        new Tire("앞왼쪽", 6),
        new Tire("앞오른쪽", 2),
        new Tire("뒤왼쪽", 3),
        new Tire("뒤오른쪽", 4)
    };
}
```

```java
tires[1] = new KumhoTire("앞오른쪽",13); 
```

위와 같이 변경할 수 있다.



##### 매개 변수의 다형성

자동 타입 변환은 필드의 값을 대입할 때도 발생하나, 주로 메소드를 호출할 때 많이 발생한다. 메소드를 호출할 때에는 매개 변수의 타입과 동일한 매개값을 지정하는 것이 정석이지만, 매개값을 다양화 하기 위해 매개 변수에 자식 타입 객체를 지정할 수도 있다. 

```java
class Driver{
    void drive(Vehicle vehicle){
        vehicle.run();
    }
}
```

위 객체를 정상적으로 호출하면 다음과 같다.

```java
Driver driver = new Driver();
vehicle vehicle = new Vehicle();
driver.drive(vehicle);
```

이 객체의 자식 클래스를 해당 메소드의 매개값으로 넘겨주면 다음과 같다.

```java
Driver driver = new Driver();
Bus bus = new Bus();
driver.drive(bus);
```

매개변수를 선언한 경우라도, 상속받는 객체가 매개값으로 사용되면 자동 타입 변환이 발생한다.

```java
Vechicle vehicle = bus;		//자동 형 변환
```

즉, 매개 변수의 타입이 클래스일 경우, 해당 클래스의 객체뿐만 아니라 자식 객체까지도 매개값으로 사용할 수 있다. 매개값으로 어떤 자식 객체가 제공되느냐에 따라 메소드의 실행 결과는 다양해질 수 있다(매개변수의 다형성). 자식 객체가 부모의 메소드를 재정의(오버라이딩)했다면 메소드 내부에서 오버라이딩된 메소드를 호출함으로서 메소드의 실행 결과는 다양해진다.

```java
void drive(Vehicle vehicle){	//Vehicle은 자식 객체
    vehicle.run();	//자식 객체가 재정의한 run()메소드 실행
}
```



##### 강제 타입 변환(Casting)

부모 타입을 자식 타입으로 변환 시키는 것을 말하며, 모든 부모 타입을 자식 클래스 타입으로 강제 변환할 수 있는 건 아니다. 자식 타입이 부모 타입으로 자동 변환한 후, 다시 자식 타입으로 변환할 때 강제 타입 변환을 사용할 수 있다.

```java
자식클래스 변수 = (자식클래스) 부모클래스타입;
```

자식 타입이 부모 타입으로 자동 변환하면, 부모 타입에 선언된 필드와 메소드만 사용 가능하다는 제약사항이 따른다. 만약 자식 타입에 선언된 필드와 메소드를 꼭 사용해야 한다면 강제 타입 변환을 해서 다시 자식 타입으로 변환한 다음 자식 타입의 필드와 메소드를 사용하면 된다.



##### 객체 타입 확인(instanceof)

강제 타입 변환은 자식 타입이 부모 타입으로 변환되어 있는 상태에서만 가능하기 때문에 다음과 같이 부모 타입의 변수가 부모 객체를 참조할 경우 자식 타입으로 변환할 수 없다.

```java
Parent parent = new Parent();
Child child = (Child) parent;	//강제 타입변환 불가능
```

부모 변수가 참조하는 객체가 부모 객체인지 확인하는 방법, 즉 어떤 객체가 어떤 클래스의 인스턴스인지 확인하려면 instanceof 연산자를 사용할 수 있다. instanceof 연산자의 좌항은 객체가 오고, 우항은 타입이 오는데, 좌장의 객체가 우항의 인스턴스이면(우항의 타입으로 객체 생성) true를 산출하고 그렇지 않으면 false를 산출한다.

```java
boolean result = 좌항(객체) instanceof 우항(타입)
```

instanceof 연산자는 매개값의 타입을 조사할때 주로 사용된다. 메소드 내에서 강제 타입 변환이 필요한 경우 반드시 매개값이 어떤 객체인지 instanceof 연산자로 확인하고 안전하게 강제 타입 변환을 해야한다.



#### 추상 클래스

##### 추상 클래스의 개념

객체를 직접 생성할 수 있는 클래스를 실체 클래스라고 하고, 이 클래스들의 공통적 특성을 추출해서 선언한 클래스를 추상 클래스라고 한다. 추상 클래스와 실체 클래스는 상속의 관계를 가지며, 추상 클래스가 부모이고 실체 클래스가 자식으로 구현되어 실체클래스는 추상 클래스의 모든 특성(필드, 메소드)을 물려받고 추가적인 특성을 가질 수 있다. 

추상 클래스는 실체 클래스의 공통되는 필드와 메소드를 추출해서 만들었기 때문에 객체를 직접 생성해서 사용할 수 없다. 즉, 추상 클래스는 new 연산자를 사용해 인스턴스를 생성시키지 못한다.

추상 클래스는 새로운 실체 클래스를 만들기 위해 부모 클래스로만 사용되며, 코드 상에서 extends 뒤에만 올 수 있는 클래스이다.



##### 추상 클래스의 용도

###### 실체 클래스들의 공통된 필드와 메소드의 이름을 통일할 목적

실체 클래스를 설계하는 사람이 여럿일 경우, 실체 클래스마다 필드와 메소드가 다른 이름을 가질 수 있고, 동일한 데이터와 기능임에도 불구하고 이름이 달라 객체마다 사용 방법이 달리지기에 추상 클래스에 상속시킴으로서 필드와 메소드 이름을 통일시킬 수 있다.

###### 실체 클래스를 작성할 때 시간 절약

공통적 필드와 메소드를 추상 클래스에 모두 선언하고, 실체 클래스마다 다른 부분만 선언하게 되면 실체 클래스를 작성하는데 시간을 절약시킬 수 있다.



##### 추상 클래스 선언

클래스 선언에 abstract 키워드를 붙여야 하며, new 연산자를 이용해 객체를 만들지 못하고 상속을 통해 자식 클래스만 만들 수 있다.

```java
public abstract class {
    //필드
    //생성자
    //메소드
}
```

추상 클래스도 일반 클래스와 같이 필드, 생성자, 메소드 선언을 할 수 있다. new 연산자로 직접 생성자를 호출할 수는 없지만, 자식 객체가 생성될 때 super(...)를 호출해 추상 클래스 객체를 생성하므로 추상클래스도 생성자가 반드시 있어야 한다.



##### 추상 메소드와 오버라이딩

추상 클래스는 실체 클래스가 공통적으로 가져야 할 필드와 메소드들을 정의해 놓은 추상적인 클래스로, 실체 클래스의 멤버(필드, 메소드)를 통일화 시키는데 목적이 있다. 실체들이 가진 메소드의 실행 내용이 동일하면 추상 클래스에 메소드를 작성하나, 메소드의 선언만 통일화하고, 실행 내용은 실체 클래스마다 달라야 하는 경우가 있다.

이런 경우에 추상 클래스에서 추상 메소드를 선언할 수 있는데, 추상 메소드는 추상 클래스에서만 선언할 수 있고, 메소드의 선언부만 있고 메소드 실행 내용인 중괄호{}가 없는 메소드를 말한다. 추상 클래스를 설계할 때, 하위 클래스가 반드시 실행 내용을 채우도록 강요하고 싶은 메소드가 있을 겨우, 해당 메소드를 추상 메소드로 선언하면 된다. 자식 클래스는 반드시 추상 메소드를 재정의(오버라이딩)해서 실행 내용을 작성해야 하는데, 그렇지 않으면 컴파일 에러가 발생한다.

```java
[public|protected] abstract 리턴타입 메소드명(매개변수, ... );
```

일반 메소드 선언과의 차이점은 abstract 키워드가 붙으며, 메소드 중괄호가 없다.
